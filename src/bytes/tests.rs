use super::{Bytes, ParseError, Unit};

#[test]
fn test_parsing_strings() {
    let cases: Vec<(&str, Result<Bytes, ParseError>)> = vec![
        ("0", Ok(Bytes(0))),
        ("1", Ok(Bytes(1))),
        ("1b", Ok(Bytes(1))),
        ("1B", Ok(Bytes(1))),
        ("1 b", Ok(Bytes(1))),
        ("1 B", Ok(Bytes(1))),
        ("1 ki", Ok(Bytes(Unit::KiByte.size()))),
        ("1 Ki", Ok(Bytes(Unit::KiByte.size()))),
        ("1 kib", Ok(Bytes(Unit::KiByte.size()))),
        ("1 KiB", Ok(Bytes(Unit::KiByte.size()))),
        ("1 mi", Ok(Bytes(Unit::MiByte.size()))),
        ("1 Mi", Ok(Bytes(Unit::MiByte.size()))),
        ("1 mib", Ok(Bytes(Unit::MiByte.size()))),
        ("1 MiB", Ok(Bytes(Unit::MiByte.size()))),
        ("1 gi", Ok(Bytes(Unit::GiByte.size()))),
        ("1 Gi", Ok(Bytes(Unit::GiByte.size()))),
        ("1 gib", Ok(Bytes(Unit::GiByte.size()))),
        ("1 GiB", Ok(Bytes(Unit::GiByte.size()))),
        ("1 ti", Ok(Bytes(Unit::TiByte.size()))),
        ("1 Ti", Ok(Bytes(Unit::TiByte.size()))),
        ("1 tib", Ok(Bytes(Unit::TiByte.size()))),
        ("1 TiB", Ok(Bytes(Unit::TiByte.size()))),
        ("1 pi", Ok(Bytes(Unit::PiByte.size()))),
        ("1 Pi", Ok(Bytes(Unit::PiByte.size()))),
        ("1 pib", Ok(Bytes(Unit::PiByte.size()))),
        ("1 PiB", Ok(Bytes(Unit::PiByte.size()))),
        ("1 ei", Ok(Bytes(Unit::EiByte.size()))),
        ("1 Ei", Ok(Bytes(Unit::EiByte.size()))),
        ("1 eib", Ok(Bytes(Unit::EiByte.size()))),
        ("1 EiB", Ok(Bytes(Unit::EiByte.size()))),
        ("1 k", Ok(Bytes(Unit::KByte.size()))),
        ("1 K", Ok(Bytes(Unit::KByte.size()))),
        ("1 kb", Ok(Bytes(Unit::KByte.size()))),
        ("1 KB", Ok(Bytes(Unit::KByte.size()))),
        ("1 m", Ok(Bytes(Unit::MByte.size()))),
        ("1 M", Ok(Bytes(Unit::MByte.size()))),
        ("1 mb", Ok(Bytes(Unit::MByte.size()))),
        ("1 MB", Ok(Bytes(Unit::MByte.size()))),
        ("1 g", Ok(Bytes(Unit::GByte.size()))),
        ("1 G", Ok(Bytes(Unit::GByte.size()))),
        ("1 gb", Ok(Bytes(Unit::GByte.size()))),
        ("1 GB", Ok(Bytes(Unit::GByte.size()))),
        ("1 t", Ok(Bytes(Unit::TByte.size()))),
        ("1 T", Ok(Bytes(Unit::TByte.size()))),
        ("1 tb", Ok(Bytes(Unit::TByte.size()))),
        ("1 TB", Ok(Bytes(Unit::TByte.size()))),
        ("1 p", Ok(Bytes(Unit::PByte.size()))),
        ("1 P", Ok(Bytes(Unit::PByte.size()))),
        ("1 pb", Ok(Bytes(Unit::PByte.size()))),
        ("1 PB", Ok(Bytes(Unit::PByte.size()))),
        ("1 e", Ok(Bytes(Unit::EByte.size()))),
        ("1 E", Ok(Bytes(Unit::EByte.size()))),
        ("1 eb", Ok(Bytes(Unit::EByte.size()))),
        ("1 EB", Ok(Bytes(Unit::EByte.size()))),
        ("", Err(ParseError::EmptyInput)),
        ("EB", Err(ParseError::MissingValue)),
        ("0.5 EB", Err(ParseError::InvalidValue)),
        ("-1 EB", Err(ParseError::InvalidValue)),
        ("1 EEEEB", Err(ParseError::InvalidUnit)),
        ("100 EB", Err(ParseError::Overflow)),
    ];

    for c in cases {
        let b = c.0.parse::<Bytes>();
        assert_eq!(b, c.1);
    }
}
